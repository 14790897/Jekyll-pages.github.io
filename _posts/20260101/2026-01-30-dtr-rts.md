---
title: DTR 与 RTS：从上古串口线到 ESP32-C3 的日志“幽灵”
date: 2026-01-30
categories:
  - tech
tags:
  - ESP32
  - DTR
  - RTS
  - Serial Monitor
---

## 前言：为什么我的串口哑巴了？

你是否遇到过这样的场景：
你买了一块合宙的 ESP32-C3 开发板（或其他使用 Native USB 的板子），兴冲冲地用 PlatformIO 写了个 `Hello World`。
编译通过，烧录成功，绿色 LED 欢快地闪烁。
然而，当你打开串口监视器（Serial Monitor）时，屏幕却是一片死寂。

你怀疑波特率错了？改了 115200，没用。
你怀疑代码没跑？加了点灯逻辑，灯明明在闪。

其实，你的代码跑得很欢，但它是个“有礼貌”的芯片——它在等你的电脑发出一个 **DTR** 信号。如果没有这个信号，它就拒绝说话。

今天我们就来扒一扒 **DTR** 和 **RTS** 这两个从上古时代活到今天的“活化石”，以及它们是如何把现代嵌入式开发者折腾得死去活来的。

---

## 一、 考古现场：RS-232 时代的“流控”

DTR (Data Terminal Ready) 和 RTS (Request To Send) 最初诞生于几十年前的 RS-232 通信标准中，用于电脑（DTE）和调制解调器（DCE）之间的握手。

* **DTR (数据终端就绪)**：这就好比你拿起电话听筒。电脑通过拉高 DTR 告诉外设：“我已经开机并在监听了，你可以准备干活了。”
* **RTS (请求发送)**：这就好比对讲机的通话键。电脑告诉外设：“我有数据要发给你，你现在忙不忙？”

在那个年代，它们是物理层面上的“交通信号灯”，防止数据发太快把机器撑死。

---

## 二、 借尸还魂：ESP32 的自动下载电路

随着 USB 转串口芯片（如 CP2102, CH340）的普及，真正的“流控”需求已经很少了（现在的芯片处理速度极快）。但是，硬件工程师们发现这两个引脚闲着也是闲着，于是发明了一个天才（也可以说反人类）的设计——**自动下载电路**。

ESP32 要烧录程序，需要满足两个条件：

1. **IO0** 拉低（进入 Boot 模式）。
2. **EN** (Reset) 拉低再拉高（重启芯片）。

以前我们需要手动按板子上的 BOOT 和 RST 键。现在，串口芯片的 **DTR** 和 **RTS** 引脚通过两个三极管连接到了 **IO0** 和 **EN** 上。

* **esptool.py**（烧录工具）在后台疯狂操控 DTR 和 RTS 的电平跳变，替你按下了那两个按钮。
* 这就是为什么你在烧录开始时，会听到 USB“叮咚”一声或者看到日志里有一堆乱码，那是电路在复位。

---

## 三、 现代幽灵：ESP32-C3/S3 的原生 USB 陷阱

到了 ESP32-C3 和 S3 时代，事情变得复杂了。

为了降低成本（省去一颗 CH340 芯片，约 1-2 元人民币），像合宙 AirM2M 这种开发板，直接使用了 C3 芯片内部的 **USB 控制器 (Native USB)** 连接电脑。

这时候，板子上没有串口芯片了，**DTR 和 RTS 变成了 USB 协议包里的虚拟标志位**。

### 这里的“坑”在于：CDC 驱动的逻辑

在 ESP32 的 Arduino Core 底层（以及很多 USB CDC 实现）中，有一段类似这样的逻辑：

```c
// 伪代码演示
void USBCDC::write(uint8_t c) {
    if (get_dtr_state() == LOW) {
        // 如果电脑没把 DTR 拉高，说明串口助手没打开
        // 或者线没插好。为了防止阻塞，我直接丢弃数据！
        return; 
    }
    send_usb_packet(c);
}

```

这就是问题的根源！

1. **对于传统的 CP2102 板子：** 只要线插着，芯片就在工作，物理引脚就在那里，ESP32 就像对着大喇叭喊话，管你听没听，它只管发。
2. **对于原生 USB C3 板子：** 它非常智能且“社恐”。它会检测主机端的状态。如果你的串口监视器（Monitor）没有显式地发送 `DTR=1` 信号，C3 就会认为对面没人，从而**彻底静音**。

---

## 四、 解决方案：PlatformIO 的终极配置

明白了原理，解决起来就非常简单了。我们需要做两件事：

1. **固件层：** 告诉 C3 芯片，启动时把日志导向 USB CDC。
2. **软件层：** 强迫电脑端的串口监视器拉高 DTR。

### 在 `platformio.ini` 中添加以下配置：

```ini
[env:airm2m_core_esp32c3]
platform = espressif32
framework = arduino
; 使用合宙板子的定义，它通常内置了 USB CDC 的宏定义
board = airm2m_core_esp32c3

; ----------------------------------------------------
; 核心配置 A：固件层 (如果 board 定义里没加，这里要手动加)
; ----------------------------------------------------
build_flags = 
    -D ARDUINO_USB_MODE=1
    -D ARDUINO_USB_CDC_ON_BOOT=1

; ----------------------------------------------------
; 核心配置 B：电脑软件层 (解决“哑巴”问题的关键)
; ----------------------------------------------------
monitor_speed = 115200
; 强制拉高 DTR 和 RTS，告诉 C3 “我准备好了”
monitor_dtr = 1
monitor_rts = 1

```

**配置解读：**

* `ARDUINO_USB_CDC_ON_BOOT=1`：这是让 ESP32 **想说话**。
* `monitor_dtr=1`：这是让电脑 **能听到**。

---

## 总结

**DTR** 和 **RTS** 这两兄弟，从几十年前控制调制解调器的“红绿灯”，演变成了自动复位电路的“机械手”，最后在 USB 原生接口时代变成了控制数据流的“软件开关”。

**如果你记不住复杂的原理，请记住这句话：**
玩 ESP32-C3/S3 的原生 USB 接口时，只要串口没打印，先把 `monitor_dtr = 1` 加进去，通常能解决 90% 的问题。

Happy Coding! 🚀